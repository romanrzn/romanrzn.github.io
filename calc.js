// Generated by CoffeeScript 1.7.1
var main,
  __slice = [].slice,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

main = function() {
  var Car, Path, Point, Table, avg, carsTable, config, dashToCamel, itemgetter, map, mapCanvas, marketsTable, op, pathsTable, prettyPrintTime, randrange, reduce, resultTable, simulate, sum, tabs, uniqueId, zip, zipWith;
  itemgetter = function(i) {
    return function(o) {
      return o[i];
    };
  };
  randrange = function(a1, a2) {
    var max, min, _ref, _ref1;
    if (a2 === void 0) {
      _ref = [0, a1], min = _ref[0], max = _ref[1];
    } else {
      _ref1 = [a1, a2], min = _ref1[0], max = _ref1[1];
    }
    return min + Math.floor(Math.random() * (max - min));
  };
  zip = function() {
    var arrays;
    arrays = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return arrays[0].map(function(_, i) {
      return arrays.map(function(a) {
        return a[i];
      });
    });
  };
  zipWith = function() {
    var arrays, f;
    f = arguments[0], arrays = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return (zip.apply(null, arrays)).map(function(a) {
      return f.apply(null, a);
    });
  };
  reduce = function(f, arr) {
    return arr.reduce(f);
  };
  map = function(f, arr) {
    return arr.map(f);
  };
  op = {
    plus: function(a, b) {
      return a + b;
    },
    minus: function(a, b) {
      return a - b;
    }
  };
  sum = function(arr) {
    return reduce(op.plus, arr);
  };
  avg = function() {
    var xs;
    xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (xs.reduce(function(a, b) {
      return a + b;
    })) / xs.length;
  };
  uniqueId = function(prefix) {
    if (prefix == null) {
      prefix = '';
    }
    return prefix + Math.random().toString();
  };
  dashToCamel = function(s) {
    return s.replace(/-[a-z]/g, function(m) {
      return m[1].toUpperCase();
    });
  };
  prettyPrintTime = function(t, precision) {
    var h, m, s, str;
    if (precision == null) {
      precision = 's';
    }
    str = "";
    h = Math.floor(t / (60 * 60));
    str += "" + h + " ч.";
    if (precision === 'h') {
      return str;
    }
    m = Math.floor((t % (60 * 60)) / 60);
    str += " " + m + " мин.";
    if (precision === 'm') {
      return str;
    }
    s = t % 60;
    str += " " + s + " ч.";
    return str;
  };
  Point = (function() {
    function Point(x, y, demand) {
      var _ref;
      this.demand = demand;
      this.click = __bind(this.click, this);
      this.dragstop = __bind(this.dragstop, this);
      this.drag = __bind(this.drag, this);
      this.dragstart = __bind(this.dragstart, this);
      Point.prototype.radius = 8;
      if (this.demand === void 0) {
        this.persistent = true;
        this.demand = 0;
      }
      _ref = [x, y], this.x = _ref[0], this.y = _ref[1];
      mapCanvas.$.drawArc({
        layer: true,
        draggable: true,
        bringToFront: true,
        data: {
          point: this
        },
        fillStyle: this.persistent ? '#37A42C' : "#F65E3B",
        x: x,
        y: y,
        radius: Point.prototype.radius,
        dragstart: this.dragstart.bind(this),
        drag: this.drag.bind(this),
        dragstop: this.dragstop.bind(this),
        click: this.click.bind(this),
        dblclick: this.dblclick.bind(this)
      });
    }

    Point.prototype.removeLayer = function() {
      return mapCanvas.$.removeLayers((function(_this) {
        return function(l) {
          return l.data.point === _this;
        };
      })(this));
    };

    Point.prototype.dragstart = function() {
      return this.stillDragging = true;
    };

    Point.prototype.drag = function(l) {
      this.x = l.x;
      return this.y = l.y;
    };

    Point.prototype.dragstop = function() {
      return setTimeout(((function(_this) {
        return function() {
          return _this.stillDragging = false;
        };
      })(this)), 100);
    };

    Point.prototype.click = function(l) {
      if (!this.stillDragging) {
        return mapCanvas.pointSelected(this);
      }
    };

    Point.prototype.dblclick = function() {
      if (this.persistent) {
        return;
      }
      return mapCanvas.removePoint(this);
    };

    Point.prototype.distanceTo = function(p) {
      var x1, x2, y1, y2, _ref, _ref1;
      _ref = mapCanvas.toReal(this.x, this.y), x1 = _ref[0], y1 = _ref[1];
      _ref1 = mapCanvas.toReal(p.x, p.y), x2 = _ref1[0], y2 = _ref1[1];
      return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    };

    return Point;

  })();
  Path = (function() {
    function Path(followCursor) {
      this.followCursor = followCursor != null ? followCursor : false;
      this.points = [];
      this.cars = [];
      mapCanvas.$.addLayer({
        type: 'function',
        data: {
          path: this
        },
        fn: this.draw.bind(this)
      });
    }

    Path.prototype.draw = function(ctx) {
      var ax, ay, i, p, _i, _len, _ref, _ref1;
      if (!this.points.length) {
        return;
      }
      ctx.globalAlpha = 0.4;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#000';
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(this.points[0].x, this.points[0].y);
      _ref = this.points.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        ctx.lineTo(p.x, p.y);
      }
      if (this.followCursor) {
        ctx.lineTo(mapCanvas.curX, mapCanvas.curY);
      }
      ctx.stroke();
      if (this.points.length > 1) {
        i = mapCanvas.paths.indexOf(this);
        _ref1 = zipWith.apply(null, [avg].concat(__slice.call(this.points.map(function(p) {
          return [p.x, p.y];
        })))), ax = _ref1[0], ay = _ref1[1];
        ctx.font = 'normal 1em Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#000';
        ctx.globalAlpha = 0.4;
        ctx.fillText('Маршрут ' + (i + 1), ax, ay);
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#F65E3B';
        return ctx.fillText(this.demand() + ' шт.', ax, ay + 16);
      }
    };

    Path.prototype.removeLayer = function() {
      return mapCanvas.$.removeLayers((function(_this) {
        return function(l) {
          return l.data.path === _this;
        };
      })(this));
    };

    Path.prototype.addPoint = function(p) {
      this.points.push(p);
      return pathsTable.update();
    };

    Path.prototype.removePoint = function(p) {
      this.points = this.points.filter(function(p_) {
        return p_ !== p;
      });
      if ((this.points.filter(function(p) {
        return !p.persistent;
      })).length === 0) {
        mapCanvas.removePath(this);
      }
      return pathsTable.update();
    };

    Path.prototype.addCar = function(c) {
      if (__indexOf.call(this.cars, c) >= 0) {
        return;
      }
      this.cars.push(c);
      return carsTable.update();
    };

    Path.prototype.removeCar = function(c) {
      this.cars = this.cars.filter(function(c_) {
        return c_ !== c;
      });
      return carsTable.update();
    };

    Path.prototype.length = function() {
      var l, p, pp, _i, _len, _ref;
      l = 0;
      pp = this.points[0];
      _ref = this.points.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        l += pp.distanceTo(p);
        pp = p;
      }
      return l;
    };

    Path.prototype.demand = function() {
      return sum(map(itemgetter('demand'), this.points));
    };

    return Path;

  })();
  Car = (function() {
    function Car(hired, capacity) {
      this.hired = hired != null ? hired : false;
      this.capacity = capacity != null ? capacity : 200;
      this.data = {};
      this.resetData();
    }

    Car.prototype.resetData = function() {
      this.data.t = 0;
      this.data.trunk = this.capacity;
      this.data.paths = {};
      this.data.boxCount = 0;
      this.data.distance = 0;
      this.data.distanceFee = 0;
      this.data.constantFee = this.hired ? config.dailyHired : config.dailyOwn;
      this.data.overtimeFee = 0;
      this.data.minUnitsPenalty = 0;
      this.data.minWorkTimePenalty = 0;
      this.data.expeditorFee = this.hired ? config.expeditor : 0;
      return this.data.totalFee = this.data.constantFee + this.data.expeditorFee;
    };

    return Car;

  })();
  Table = (function() {
    function Table(id, addRemoveBtn, vertical) {
      this.id = id;
      this.addRemoveBtn = addRemoveBtn != null ? addRemoveBtn : true;
      this.vertical = vertical != null ? vertical : false;
      this.$ = $('#' + id);
    }

    Table.prototype.updateHorizontal = function() {
      var row, tbody, td, _i, _len, _ref, _ref1, _results;
      this.$.find('tr').slice(1).remove();
      tbody = this.$.children('tbody');
      _ref = this.rows();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        _results.push(tbody.append((_ref1 = $('<tr>')).append.apply(_ref1, ((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
            td = row[_j];
            _results1.push($('<td>').append(td));
          }
          return _results1;
        })())).append(this.addRemoveBtn ? $('<td>').append($('<button>').append('Удалить').button().click(this.remove.bind(this, row))) : '')));
      }
      return _results;
    };

    Table.prototype.updateVertical = function() {
      var row, _i, _len, _ref, _results;
      this.$.find('td').remove();
      _ref = this.rows();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        _results.push(this.$.find('tr').each(function(i) {
          return $(this).append($('<td>').append(row[i]));
        }));
      }
      return _results;
    };

    Table.prototype.update = function() {
      if (this.vertical) {
        return this.updateVertical();
      } else {
        return this.updateHorizontal();
      }
    };

    Table.prototype.rows = function() {
      throw new Error('Subclass should supply rows method.');
    };

    Table.prototype.remove = function(row) {
      throw new Error('Subclass should supply remove method.');
    };

    return Table;

  })();
  $.widget("ui.suffixSpinner", $.ui.spinner, {
    _create: (function() {
      this._super();
      this.options["default"] = this.options["default"] || this.element.attr('default') || 0;
      this.options.suffix = this.options.suffix || this.element.attr('suffix') || '';
      return this.element.val(this.options["default"] + ' ' + this.options.suffix);
    }),
    _format: (function(value) {
      return value + ' ' + this.options.suffix;
    }),
    _parse: (function(value) {
      return parseInt(value);
    })
  });
  pathsTable = new ((function(_super) {
    __extends(_Class, _super);

    function _Class() {
      return _Class.__super__.constructor.apply(this, arguments);
    }

    _Class.prototype.rows = function() {
      var i, path, pointsCount, _ref, _results;
      _ref = mapCanvas.paths;
      _results = [];
      for (i in _ref) {
        path = _ref[i];
        pointsCount = path.points.filter(function(p) {
          return !p.persistent;
        }).length;
        _results.push([parseInt(i) + 1, pointsCount, path.demand()]);
      }
      return _results;
    };

    _Class.prototype.remove = function(_arg) {
      var i, _;
      i = _arg[0], _ = 2 <= _arg.length ? __slice.call(_arg, 1) : [];
      return mapCanvas.removePath(mapCanvas.paths[parseInt(i) - 1]);
    };

    return _Class;

  })(Table))('paths-table');
  marketsTable = new ((function(_super) {
    __extends(_Class, _super);

    function _Class() {
      return _Class.__super__.constructor.apply(this, arguments);
    }

    _Class.prototype.rows = function() {
      var demand, i, p, _ref, _results;
      _ref = mapCanvas.points;
      _results = [];
      for (i in _ref) {
        p = _ref[i];
        if (p.persistent) {
          continue;
        }
        demand = $("<input type='text'>");
        demand.suffixSpinner({
          min: 1,
          max: 9999,
          "default": p.demand,
          suffix: 'шт',
          change: (function(p) {
            return function(e) {
              p.demand = parseInt(e.target.value);
              return mapCanvas.$.drawLayers();
            };
          })(p)
        });
        demand.width(80);
        demand = demand.parent();
        _results.push([i, demand]);
      }
      return _results;
    };

    _Class.prototype.remove = function(_arg) {
      var i, _;
      i = _arg[0], _ = 2 <= _arg.length ? __slice.call(_arg, 1) : [];
      return mapCanvas.removePoint(mapCanvas.points[i]);
    };

    return _Class;

  })(Table))('markets-table');
  carsTable = new ((function(_super) {
    __extends(_Class, _super);

    function _Class() {
      $('#car-add').button().click(this.addCar.bind(this));
      _Class.__super__.constructor.apply(this, arguments);
    }

    _Class.prototype.rows = function() {
      var box, capacity, car, hired, hiredLabel, hiredOwn, i, id, id1, id2, j, lbl, own, ownLabel, p, routes, _ref, _ref1, _results;
      _ref = mapCanvas.cars;
      _results = [];
      for (i in _ref) {
        car = _ref[i];
        id1 = uniqueId();
        hired = $("<input type='radio' name='hired" + id1 + "' id='" + id1 + "'>");
        if (car.hired) {
          hired.attr('checked', 'checked');
        }
        hiredLabel = $("<label for='" + id1 + "'>").append('Наёмная');
        id2 = uniqueId();
        own = $("<input type='radio' name='hired" + id1 + "' id='" + id2 + "'>").change((function(car) {
          return function(e) {
            return car.hired = $(this).is(':checked');
          };
        })(car));
        if (!car.hired) {
          own.attr('checked', 'checked');
        }
        ownLabel = $("<label for='" + id2 + "'>").append('Собственная');
        hiredOwn = $('<div>').append(hired, hiredLabel, own, ownLabel).buttonset();
        capacity = $("<input type='text'>");
        capacity.suffixSpinner({
          min: 1,
          max: 9999,
          "default": car.capacity,
          suffix: 'шт',
          change: (function(car) {
            return function(e) {
              return car.capacity = parseInt(e.target.value);
            };
          })(car)
        });
        capacity.width(80);
        capacity = capacity.parent();
        routes = $('<div>');
        _ref1 = mapCanvas.paths;
        for (j in _ref1) {
          p = _ref1[j];
          id = uniqueId();
          box = $("<input type='checkbox' id='" + id + "'>");
          if (__indexOf.call(p.cars, car) >= 0) {
            box.attr('checked', 'checked');
          }
          box.change((function(car, p) {
            return function(e) {
              if ($(this).is(':checked')) {
                return p.addCar(car);
              } else {
                return p.removeCar(car);
              }
            };
          })(car, p));
          lbl = $("<label for='" + id + "'>").append(parseInt(j) + 1);
          routes.append(box, lbl);
        }
        routes.buttonset();
        _results.push([parseInt(i) + 1, hiredOwn, capacity, routes]);
      }
      return _results;
    };

    _Class.prototype.addCar = function() {
      return mapCanvas.addCar(new Car);
    };

    _Class.prototype.remove = function(_arg) {
      var i, _;
      i = _arg[0], _ = 2 <= _arg.length ? __slice.call(_arg, 1) : [];
      return mapCanvas.removeCar(mapCanvas.cars[i - 1]);
    };

    return _Class;

  })(Table))('cars-table');
  resultTable = new ((function(_super) {
    __extends(_Class, _super);

    function _Class() {
      $('#calculate').button().click(this.update.bind(this));
      $('a[href="#tabs-result"]').click(this.update.bind(this));
      _Class.__super__.constructor.apply(this, arguments);
    }

    _Class.prototype.rows = function() {
      var c, i, j, row, rows, total, _, _ref;
      simulate();
      total = 0;
      rows = [];
      _ref = mapCanvas.cars;
      for (i in _ref) {
        c = _ref[i];
        row = [parseInt(i) + 1];
        row.push(c.hired ? 'Наёмная' : 'Своя');
        row.push(([
          (function() {
            var _ref1, _results;
            _ref1 = c.data.paths;
            _results = [];
            for (j in _ref1) {
              _ = _ref1[j];
              _results.push(parseInt(j) + 1);
            }
            return _results;
          })()
        ].join(', ')) || 'ни одного');
        row.push(prettyPrintTime(c.data.t, 'm'));
        row.push(c.data.boxCount + ' шт');
        row.push((c.data.distance / 1000).toFixed(2) + ' км');
        row.push(c.data.distanceFee.toFixed(2) + ' руб');
        row.push(c.data.constantFee.toFixed(2) + ' руб');
        row.push(c.data.overtimeFee.toFixed(2) + ' руб');
        row.push(c.data.minUnitsPenalty.toFixed(2) + ' руб');
        row.push(c.data.minWorkTimePenalty.toFixed(2) + ' руб');
        row.push(c.data.expeditorFee.toFixed(2) + ' руб');
        row.push(c.data.totalFee.toFixed(2) + ' руб');
        total += c.data.totalFee;
        rows.push(row);
      }
      $('#total-total').text("Всего: " + (total.toFixed(2)) + " руб");
      return rows;
    };

    return _Class;

  })(Table))('result-table', false, true);
  simulate = function() {
    var c, cars, d, demand, i, p, path, pointsQueue, pp, t, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
    _ref = mapCanvas.cars;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      c.resetData();
    }
    _ref1 = mapCanvas.paths;
    for (i in _ref1) {
      path = _ref1[i];
      cars = path.cars.slice();
      c = cars.pop();
      if (!c) {
        continue;
      }
      pp = path.points[0];
      pointsQueue = path.points.slice(1).slice();
      c.data.trunk = c.capacity;
      while (p = pointsQueue.shift()) {
        d = pp.distanceTo(p);
        demand = p.demand;
        t = d / config.speed + demand * config.unloadSpeed + config.paperSpeed;
        if (c.data.t + t > config.driverMaxWorkTime) {
          c = cars.pop();
          if (!c) {
            break;
          }
          pointsQueue.unshift(p);
          continue;
        }
        if (c.data.trunk < demand) {
          (function() {})();
        }
        c.data.paths[i] = true;
        c.data.trunk -= demand;
        c.data.boxCount += demand;
        c.data.distance += d;
        c.data.distanceFee += (c.hired ? config.kmHired : config.kmOwn) * d / 1000;
        c.data.totalFee += c.data.distanceFee;
        c.data.t += t;
        if (c.data.t > config.driverWorkTime && !c.data.overtimeFee) {
          c.data.overtimeFee += config.driverOvertime;
          c.data.totalFee += c.data.overtimeFee;
        }
        pp = p;
      }
    }
    _ref2 = mapCanvas.cars;
    _results = [];
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      c = _ref2[_j];
      if (c.data.boxCount < config.minUnits) {
        c.data.minUnitsPenalty += config.minUnitsPenalty * (config.minUnits - c.data.boxCount);
        c.data.totalFee += c.data.minUnitsPenalty;
      }
      if (c.data.t < config.minWorkTime) {
        c.data.minWorkTimePenalty += c.hired ? config.minOwnWorkTimePenalty : config.minHiredWorkTimePenalty;
        _results.push(c.data.totalFee += c.data.minWorkTimePenalty);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };
  config = {
    init: function() {
      this.$ = $('#tabs-config');
      $('#config-apply').button().click(this.apply.bind(this));
      return this.apply();
    },
    apply: function() {
      this.$.find('input[wrapme="spinner"]').each(function() {
        return config[dashToCamel(this.id)] = $(this).suffixSpinner('value');
      });
      this.speed = this.speed * 0.277778;
      this.paperSpeed = this.paperSpeed * 60;
      this.driverWorkTime = this.driverWorkTime * 60 * 60;
      this.driverMaxWorkTime = this.driverMaxWorkTime * 60 * 60;
      this.driverOvertime = this.driverOvertime / 60 / 60;
      this.minWorkTime = this.minWorkTime * 60 * 60;
      return mapCanvas.setRealSize(this.mapRealWidth, this.mapRealHeight);
    }
  };
  (function() {
    return $('[wrapme="spinner"]').each(function(i) {
      $(this).suffixSpinner({
        min: 1,
        max: 999999
      });
      return $(this).width($(this).attr('width_') || 80);
    });
  })();
  tabs = {
    init: function() {
      this.$ = $('#tabs');
      return this.$.tabs();
    }
  };
  mapCanvas = {
    points: [],
    paths: [],
    cars: [],
    init: function() {
      var car, hh, hw, i, kx, ky, p, path, x, y, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
      this.$ = $('#map-canvas');
      this.initBg();
      this.initCrosshair();
      this.initPointsInfo();
      this.initHelp();
      config.init();
      tabs.init();
      this.pathMode = false;
      this.w = this.$.width();
      this.h = this.$.height();
      this.$.drawRect({
        layer: true,
        fillStyle: 'rgba(0, 0, 0, 0)',
        x: this.w / 2,
        y: this.h / 2,
        width: this.w,
        height: this.h,
        dblclick: this.dblclick.bind(this),
        click: this.click.bind(this)
      });
      this.addPoint(new Point(this.w / 2, this.h / 2));
      _ref = [this.w / 2, this.h / 2], hw = _ref[0], hh = _ref[1];
      for (i = _i = 0; _i <= 7; i = ++_i) {
        _ref1 = [(i & 1 << 2) >> 2, (i & 1 << 1) >> 1], kx = _ref1[0], ky = _ref1[1];
        _ref2 = [randrange(hw * kx, hw + hw * kx), randrange(hh * ky, hh + hh * ky)], x = _ref2[0], y = _ref2[1];
        this.addPoint(new Point(x, y, randrange(100)));
      }
      for (i = _j = 1; _j <= 6; i = _j += 2) {
        path = new Path;
        path.addPoint(this.points[0]);
        _ref3 = this.points.slice(i, +(i + 1) + 1 || 9e9);
        for (_k = 0, _len = _ref3.length; _k < _len; _k++) {
          p = _ref3[_k];
          path.addPoint(p);
        }
        path.addPoint(this.points[0]);
        this.addPath(path);
      }
      car = new Car;
      this.addCar(car);
      _ref4 = this.paths;
      for (_l = 0, _len1 = _ref4.length; _l < _len1; _l++) {
        p = _ref4[_l];
        p.addCar(car);
      }
      return this.$.drawLayers();
    },
    setRealSize: function(w, h) {
      this.realW = w;
      return this.realH = h;
    },
    toCanvas: function(x, y) {
      return [x * this.w / this.realW, y * this.h / this.realH].map(Math.round);
    },
    toReal: function(x, y) {
      return [x * this.realW / this.w, y * this.realH / this.h].map(Math.round);
    },
    initBg: function() {
      var bg, step;
      bg = $('<canvas>');
      step = 15;
      bg[0].width = bg[0].height = step;
      bg.drawLine({
        strokeStyle: '#BBADA0',
        strokeWidth: 1,
        x1: step,
        y1: 0,
        x2: step,
        y2: step,
        x3: 0,
        y3: step
      });
      return this.$.css({
        'background': "url(" + (bg[0].toDataURL('image/png')) + ") repeat"
      });
    },
    initCrosshair: function() {
      var x, y;
      x = y = null;
      this.$.on('mousemove', (function(_this) {
        return function(e) {
          _this.curX = x = Math.round(e.pageX - _this.$.offset().left);
          return _this.curY = y = Math.round(e.pageY - _this.$.offset().top);
        };
      })(this));
      this.$.on('mouseout', (function(_this) {
        return function(e) {
          x = y = null;
          return _this.$.drawLayers();
        };
      })(this));
      return this.$.addLayer({
        type: 'function',
        name: 'crosshair',
        fn: (function(_this) {
          return function(ctx) {
            var l, rx, ry, t, _ref;
            if (x === null) {
              return;
            }
            ctx.globalAlpha = 1;
            _this.$.drawLine({
              strokeStyle: '#8F7A66',
              strokeWidth: 1,
              x1: x - .5,
              y1: .5,
              x2: x - .5,
              y2: _this.h + .5
            });
            _this.$.drawLine({
              strokeStyle: '#8F7A66',
              strokeWidth: 1,
              x1: .5,
              y1: y + .5,
              x2: _this.w + .5,
              y2: y + .5
            });
            _ref = _this.toReal(x, y), rx = _ref[0], ry = _ref[1];
            ctx.font = 'normal 1em Arial';
            ctx.fillStyle = '#8F7A66';
            l = x < _this.w / 2;
            t = y < _this.h / 2;
            ctx.textAlign = l ? 'left' : 'right';
            ctx.fillText(rx + ' м', x + (l ? 4 : -4), t ? _this.h - 4 : 16);
            ctx.textAlign = l ? 'right' : 'left';
            return ctx.fillText(ry + ' м', l ? _this.w - 4 : 4, y + (t ? 16 : -4));
          };
        })(this)
      });
    },
    initPointsInfo: function() {
      return this.$.addLayer({
        type: 'function',
        fn: ((function(_this) {
          return function(ctx) {
            var i, p, _ref, _results;
            ctx.globalAlpha = 1;
            ctx.font = 'normal 1em Arial';
            _ref = _this.points;
            _results = [];
            for (i in _ref) {
              p = _ref[i];
              ctx.textAlign = 'left';
              ctx.fillStyle = '#8F7A66';
              ctx.fillText(p.persistent ? 'Склад' : 'Магазин ' + i, p.x + 16, p.y + 6);
              if (p.demand) {
                ctx.textAlign = 'right';
                ctx.fillStyle = '#F65E3B';
                ctx.fillText(p.demand + ' шт.', p.x + -16, p.y + 6);
              }
              if (_this.selectedPoint === p) {
                _results.push(_this.$.drawArc({
                  fillStyle: "#8F7A66",
                  x: p.x,
                  y: p.y,
                  radius: Point.prototype.radius + 2
                }));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          };
        })(this))
      });
    },
    initHelp: function() {
      var click, mousedown;
      mousedown = (function(_this) {
        return function() {
          _this.$.off('mousedown', mousedown);
          return $('#help').fadeOut();
        };
      })(this);
      this.$.on('mousedown', mousedown);
      click = function() {
        $(this).off('click', click);
        return $(this).fadeOut();
      };
      return $('#help').on('click', click);
    },
    addPath: function(p) {
      this.paths.push(p);
      pathsTable.update();
      return carsTable.update();
    },
    removePath: function(p) {
      this.paths = this.paths.filter(function(p_) {
        return p_ !== p;
      });
      p.removeLayer();
      pathsTable.update();
      carsTable.update();
      return this.$.drawLayers();
    },
    addPoint: function(p) {
      this.points.push(p);
      return marketsTable.update();
    },
    removePoint: function(p) {
      var path, _i, _len, _ref;
      this.points = this.points.filter(function(p_) {
        return p_ !== p;
      });
      _ref = this.paths;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        path = _ref[_i];
        path.removePoint(p);
      }
      p.removeLayer();
      marketsTable.update();
      return this.$.drawLayers();
    },
    addCar: function(c) {
      if (__indexOf.call(this.cars, c) >= 0) {
        return;
      }
      this.cars.push(c);
      return carsTable.update();
    },
    removeCar: function(c) {
      this.cars = this.cars.filter(function(c_) {
        return c_ !== c;
      });
      return carsTable.update();
    },
    dblclick: function(l) {
      return this.addPoint(new Point(l.eventX, l.eventY, 1));
    },
    click: function(l) {
      return this.selectedPoint = null;
    },
    pointSelected: function(p) {
      var path;
      if (p.persistent) {
        this.togglePathMode();
        if (this.pathMode) {
          path = new Path(true);
          path.addPoint(p);
          this.addPath(path);
        } else {
          path = this.paths[this.paths.length - 1];
          path.followCursor = false;
          path.addPoint(p);
          if (path.points.every(function(p) {
            return p.persistent;
          })) {
            path.removeLayer();
            this.removePath(path);
          }
        }
      }
      if (this.pathMode) {
        if (!this.paths.some(function(path) {
          return __indexOf.call(path.points, p) >= 0;
        })) {
          return this.paths[this.paths.length - 1].addPoint(p);
        }
      }
    },
    togglePathMode: function() {
      return this.pathMode = !this.pathMode;
    }
  };
  return mapCanvas.init();
};

$(main);
