// Generated by CoffeeScript 1.8.0
var assert, binaryField, binomial, compare, compose, concat, concatMap, concatMap_, exp, factorial, filter, filter_, flip2, frange, group, groupBy, groupBy_, len, log, log2, map, map_, maximum, memo1, minimum, ncalls, ncalls_, op, partial1, product, range, reduce, reduce_, replicate, splitEvery, sum, upon, zip, zipWith, zipWith_,
  __slice = [].slice;

assert = function(bool, msg) {
  if (msg == null) {
    msg = 'no message supplied';
  }
  if (!bool) {
    throw new Error("Assertion Error: " + msg);
  }
};

flip2 = function(f) {
  return function() {
    var a, b, rest;
    a = arguments[0], b = arguments[1], rest = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return f.call.apply(f, [this, b, a].concat(__slice.call(rest)));
  };
};

memo1 = function(f) {
  var cache;
  cache = Object.create(null);
  return function(a) {
    var v;
    if (a in cache) {
      return cache[a];
    }
    v = f.call.apply(f, [this].concat(__slice.call(arguments)));
    cache[a] = v;
    return v;
  };
};

upon = function(binop, g) {
  return function(a, b) {
    return binop(g(a), g(b));
  };
};

compose = function(f, g) {
  return function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return f(g.apply(null, args));
  };
};

partial1 = function(f, a) {
  return function() {
    var rest;
    rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return f.apply(null, [a].concat(__slice.call(rest)));
  };
};

exp = function(x) {
  return Math.exp(x);
};

log = function(x, base) {
  if (base == null) {
    base = false;
  }
  if (base) {
    return Math.log(x) / Math.log(base);
  } else {
    return Math.log(x);
  }
};

log2 = function(x) {
  return log(x, 2);
};

factorial = memo1(function(n) {
  if (n < 2) {
    return 1;
  }
  return n * factorial(n - 1);
});

binomial = function(n, k) {
  return factorial(n) / (factorial(n - k) * factorial(k));
};

op = {
  not: function(a) {
    return !a;
  },
  intnot: function(a) {
    return 0 + !a;
  },
  eq: function(a, b) {
    return a === b;
  },
  add: function(a, b) {
    return a + b;
  },
  mul: function(a, b) {
    return a * b;
  },
  and: function(a, b) {
    return a && b;
  },
  or: function(a, b) {
    return a || b;
  },
  xor: function(a, b) {
    return a ^ b;
  }
};

binaryField = new ((function() {
  var bit;

  function _Class() {}

  bit = function(i, n) {
    return (n & (1 << i)) >> i;
  };

  _Class.prototype.degree = function(p) {
    if (p === 0) {
      return -1;
    } else {
      return Math.floor(log2(p));
    }
  };

  _Class.prototype.add = op.xor;

  _Class.prototype.mul = function(p, h) {
    return reduce(op.xor, map_(filter_(range(Math.max(0, this.degree(p))), function(n) {
      return bit(p, n);
    }), function(n) {
      return h << n;
    }), r);
  };

  _Class.prototype.divmod = function(p, h) {
    var d, hd, m, md;
    assert(h > 0, 'division by zero');
    hd = this.degree(h);
    m = p;
    md = this.degree(m);
    d = 0;
    while (md >= hd) {
      d ^= 1 << (md - hd);
      m ^= h << (md - hd);
      md = this.degree(m);
    }
    return [d, m];
  };

  _Class.prototype.div = function(p, h) {
    return (this.divmod(p, h))[0];
  };

  _Class.prototype.mod = function(p, h) {
    return (this.divmod(p, h))[1];
  };

  return _Class;

})());


/*
do test = ->
  try
    bf = binaryField
    for p1 in [0...2**4]
      divzok = yes
      try
        bf.div p1, 0 # should throw
        divzok = no
      assert divzok, 'division by zero throws'
      assert (p1 == bf.mul p1, 1), 'bf.mul 1 identity'
      for p2 in [0...2**4]
        mul = bf.mul p1, p2
        mul1 = bf.mul p2, p1
        assert mul == mul1, 'bf.mul commutativity'
        assert 0 == mul, 'bf.mul 0' if p1 == 0 or p2 == 0
        assert (p1 == bf.div mul, p2), 'bf.mul is inverse of bf.div' if p2 != 0
        assert (0 == bf.mod mul, p2), 'bf.mod == 0' if mul != 0
  catch e
    try
      console.log p1.toString(2), p2.toString(2)
    catch e2
      console.log p1, p2
    throw e
  console.log 'test ok'
 */

zip = function() {
  var arrays;
  arrays = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return arrays[0].map(function(_, i) {
    return arrays.map(function(a) {
      return a[i];
    });
  });
};

zipWith = function() {
  var arrays, f;
  f = arguments[0], arrays = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  return (zip.apply(null, arrays)).map(function(a) {
    return f.apply(null, a);
  });
};

zipWith_ = flip2(zipWith);

reduce = function(f, arr, zero) {
  switch (arguments.length) {
    case 2:
      return arr.reduce(f);
    case 3:
      return arr.reduce(f, zero);
  }
};

reduce_ = flip2(reduce);

map = function(f, arr) {
  return arr.map(f);
};

map_ = flip2(map);

filter = function(f, arr) {
  return arr.filter(f);
};

filter_ = flip2(filter);

range = function() {
  var args, end, i, start, step, _i, _j, _results, _results1;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  switch (args.length) {
    case 1:
      end = args[0];
      return (function() {
        _results = [];
        for (var _i = 0; 0 <= end ? _i < end : _i > end; 0 <= end ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
    case 2:
      start = args[0], end = args[1];
      return (function() {
        _results1 = [];
        for (var _j = start; start <= end ? _j < end : _j > end; start <= end ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this);
    case 3:
      start = args[0], end = args[1], step = args[2];
      return (function() {
        var _k, _results2;
        _results2 = [];
        for (i = _k = start; step > 0 ? _k < end : _k > end; i = _k += step) {
          _results2.push(i);
        }
        return _results2;
      })();
    default:
      throw new Error('Invalid number of arguments');
  }
};

frange = function(start, end, step) {
  var data, i, x;
  switch (typeof step) {
    case 'number':
      return (function() {
        var _i, _results;
        _results = [];
        for (i = _i = start; step > 0 ? _i < end : _i > end; i = _i += step) {
          _results.push(i);
        }
        return _results;
      })();
    case 'function':
      data = [];
      x = start;
      while (x < end) {
        data.push(x);
        x += step(x);
      }
      return data;
  }
};

sum = function(arr) {
  return reduce(op.add, arr, 0);
};

product = function(arr) {
  return reduce(op.mul, arr, 1);
};

maximum = function(arr) {
  return reduce_(arr, function(a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  });
};

minimum = function(arr) {
  return reduce_(arr, function(a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  });
};

compare = function(a, b) {
  switch (true) {
    case a < b:
      return -1;
    case a === b:
      return 0;
    case a > b:
      return 1;
  }
};

len = function(a) {
  switch (typeof a.length) {
    case 'number':
      return a.length;
    case 'function':
      return a.length();
  }
};

splitEvery = function(n, arr) {
  var chunk, i, result, x, _i, _len;
  assert(n > 0);
  result = [];
  chunk = [];
  for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
    x = arr[i];
    if (i && i % n === 0) {
      result.push(chunk);
      chunk = [];
    }
    chunk.push(x);
  }
  return result;
};

ncalls = function() {
  var args, f, i, n, _i, _results;
  f = arguments[0], n = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
  _results = [];
  for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
    _results.push(f.apply(null, args));
  }
  return _results;
};

ncalls_ = flip2(ncalls);

concat = function(arr) {
  var _ref;
  return (_ref = []).concat.apply(_ref, arr);
};

concatMap = compose(concat, map);

concatMap_ = flip2(concatMap);

replicate = function(n, e) {
  var i, _i, _results;
  _results = [];
  for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
    _results.push(e);
  }
  return _results;
};

groupBy = function(f, arr) {
  var chunk, chunks, e, pe, _i, _len, _ref;
  if (!len(arr)) {
    return [];
  }
  pe = arr[0];
  chunks = [];
  chunk = [pe];
  _ref = arr.slice(1);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    e = _ref[_i];
    if (f(pe, e)) {
      chunk.push(e);
    } else {
      chunks.push(chunk);
      chunk = [e];
    }
    pe = e;
  }
  return chunks;
};

groupBy_ = flip2(groupBy);

group = function(arr) {
  return groupBy(op.eq, arr);
};

//# sourceMappingURL=stuff.js.map
