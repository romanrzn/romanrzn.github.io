// Generated by CoffeeScript 1.8.0
var blockeq, ent_ratio, entropy, entropy_max, makeCodec, makeDecoder, makeEncoder, randstr, redundancy, traverse, zeropad;

zeropad = function(s, l, zero) {
  if (zero == null) {
    zero = '0';
  }
  while (s.length < l) {
    s = zero + s;
  }
  return s;
};

traverse = function(tree, visitors) {
  var in_, post, pre;
  if (!tree) {
    return;
  }
  pre = visitors.pre, in_ = visitors["in"], post = visitors.post;
  if (pre) {
    pre(tree);
  }
  traverse(tree.left, visitors);
  if (in_) {
    in_(tree);
  }
  traverse(tree.right, visitors);
  if (post) {
    return post(tree);
  }
};

blockeq = function(a, b) {
  return (zip(a, b)).every(function(_arg) {
    var a, b;
    a = _arg[0], b = _arg[1];
    return a === b;
  });
};

makeEncoder = function(tree) {
  return function(block) {
    var e, found, stack;
    stack = [];
    found = {};
    try {
      traverse(tree, {
        pre: function(n) {
          if (n.block && blockeq(n.block, block)) {
            throw found;
          }
          return stack.push('0');
        },
        "in": function() {
          stack.pop();
          return stack.push('1');
        },
        post: function() {
          return stack.pop();
        }
      });
    } catch (_error) {
      e = _error;
      if (e === found) {
        return stack;
      } else {
        throw e;
      }
    }
    throw new Error("Couldn't find block " + block + " in the tree");
  };
};

makeDecoder = function(tree) {
  return function(msg) {
    var node, s, _i, _len;
    node = tree;
    for (_i = 0, _len = msg.length; _i < _len; _i++) {
      s = msg[_i];
      switch (s) {
        case '0':
          node = node.left;
          break;
        case '1':
          node = node.right;
      }
    }
    return node.block;
  };
};

makeCodec = function(tree) {
  return [makeEncoder(tree), makeDecoder(tree)];
};

randstr = function(length, base) {
  if (base == null) {
    base = 2;
  }
  return Math.random().toString(base).slice(2, 2 + length);
};

entropy = function(ps) {
  return -sum(map((function(p) {
    return p * log2(p);
  }), ps));
};

entropy_max = function(ps) {
  return log2(ps.length);
};

ent_ratio = function(ps) {
  return entropy(ps) / entropy_max(ps);
};

redundancy = function(ps) {
  return 1 - ent_ratio(ps);
};

$(function() {
  var k, m, p, selector, _i, _len, _ref;
  p = {
    0: .3,
    1: .7
  };
  k = 1000;
  m = 3;
  config.define({
    title: 'p<sub>0</sub>',
    "default": p[0],
    valid: function(v) {
      return v > 0 && v < 1;
    },
    change: function(v) {
      p[0] = v;
      return p[1] = 1 - v;
    },
    $: {
      min: 0.01,
      max: 0.99
    }
  });
  config.define({
    title: 'Длина последовательности',
    "default": k,
    valid: function(v) {
      return v > 1;
    },
    change: function(v) {
      return k = v;
    }
  });
  config.define({
    title: 'Длина блока',
    "default": m,
    valid: function(v) {
      return v > 0;
    },
    change: function(v) {
      return m = v;
    }
  });
  _ref = ['#sequence', '#code', '#decoded'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    selector = _ref[_i];
    $(selector).spinner({
      spin: function() {
        return false;
      }
    });
    $(selector).css('margin-right', '.4em');
    $(selector).parent().children('.ui-spinner-button').remove();
  }
  $('#apply-config').button().click(function() {
    var blocks, blocks_probs, codes, decode, decoded, encode, getprob, graph, left, loosers, nodes, numToBlock, relent, relent_val, right, sequences, symcount, tree, _ref1, _ref2;
    symcount = Object.keys(p).length;
    numToBlock = function(n) {
      return (zeropad(n.toString(symcount), m)).split('');
    };
    blocks = map(numToBlock, range(Math.pow(symcount, m)));
    blocks_probs = zip(blocks, map_(blocks, function(b) {
      return product(map_(b, function(s) {
        return p[s];
      }));
    }));
    nodes = map_(blocks_probs, function(_arg) {
      var b, p;
      b = _arg[0], p = _arg[1];
      return {
        block: b,
        probability: p
      };
    });
    getprob = function(n) {
      return n.probability;
    };
    while (len(nodes) > 1) {
      nodes.sort(upon(compare, getprob));
      _ref1 = loosers = nodes.slice(0, 2), left = _ref1[0], right = _ref1[1];
      nodes.splice(0, 2, {
        left: left,
        right: right,
        probability: sum(map_(loosers, getprob))
      });
    }
    tree = nodes[0];
    _ref2 = makeCodec(tree), encode = _ref2[0], decode = _ref2[1];
    sequences = ncalls_(k, function() {
      return randstr(m).split('');
    });
    codes = map(encode, sequences);
    decoded = map(decode, codes);
    $('#sequence').val(sequences.map(function(s) {
      return s.join('');
    }).join(','));
    $('#code').val(codes.map(function(s) {
      return s.join('');
    }).join(','));
    $('#decoded').val(decoded.map(function(s) {
      return s.join('');
    }).join(','));
    $('#avg-length-est').text(sprintf('%.3f', (sum(map(len, codes))) / k));
    $('#avg-length').text(sprintf('%.3f', sum(map_(blocks_probs, function(_arg) {
      var b, p;
      b = _arg[0], p = _arg[1];
      return (len(encode(b))) * p;
    }))));
    relent = function(ps) {
      return (entropy(ps)) / (entropy_max(ps));
    };
    $('#relative-entropy').text(sprintf('%.3f', relent_val = relent(map_(blocks_probs, function(_arg) {
      var p, _;
      _ = _arg[0], p = _arg[1];
      return p;
    }))));
    $('#redundancy').text(sprintf('%.3f', 1 - relent_val));
    graph = cytoscape({
      container: $('#tree')[0],
      style: cytoscape.stylesheet().selector('node').css({
        'content': 'data(label)'
      }).selector('node[block > 0]').css({
        'background-color': 'OrangeRed '
      }).selector('edge').css({
        'content': 'data(label)',
        'target-arrow-shape': 'triangle',
        'width': 4,
        'line-color': '#bbb',
        'target-arrow-color': '#bbb'
      }).selector('.highlighted').css({
        'background-color': '#61bffc',
        'line-color': '#61bffc',
        'target-arrow-color': '#61bffc',
        'transition-property': 'background-color, line-color, target-arrow-color',
        'transition-duration': '0.5s'
      }),
      layout: {
        name: 'breadthfirst',
        directed: true,
        padding: 10
      }
    });
    traverse(tree, {
      pre: function(node) {
        var block, label;
        node._id = 'id' + Math.random().toString();
        if (node.block) {
          label = "" + (node.block.join('')) + " / " + (sprintf('%.3f', node.probability));
          block = true;
        } else {
          label = sprintf('%.3f', node.probability);
          block = false;
        }
        return graph.add({
          group: "nodes",
          data: {
            id: node._id,
            label: label,
            block: block
          }
        });
      }
    });
    return traverse(tree, {
      pre: function(node) {
        if (node.block) {
          return;
        }
        graph.add({
          group: 'edges',
          data: {
            source: node._id,
            target: node.left._id,
            label: '0'
          }
        });
        return graph.add({
          group: 'edges',
          data: {
            source: node._id,
            target: node.right._id,
            label: '1'
          }
        });
      }
    });
  });
  return $('#apply-config').click();
});

//# sourceMappingURL=main.js.map
